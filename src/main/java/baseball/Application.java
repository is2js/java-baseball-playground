package baseball;

public class Application {
    public static void main(String[] args) {
        // 1. 예전이라면 main안에 다 작성했을 것이다.
//        // 1-1. 예를 들어, 배열들 만들어서.
//        int[] computer = {1, 2, 3};
//        int[] player = {1, 2, 3};
//        //2배열을 파라미터로 해서 비교메서드로 비교 후 -> 문자열로 결과값이 담겨오길 원한다.
//        "1볼 1스트라이크" = match(computer, player);

        // 2. but 기능별로 적당한 클래스들을 만들어서 찾아 사용하게 된다.
        // - 객체지향:
        // 1. 기능을 모아서 가지고 있는 클래스를 -> 인스턴스화(객체) 한다.
        // 2. 각 인스턴스가  (책임분리된 메소드들로 역할에 맞게) 각 필요한 기능을 하도록 수행하게 한다.(의인화)
        // 3. 각 결과를 (객체단위? 클래스단위?로 결과값을 받았다가 ->) 종합한다.

//        3. 이제 기능 목록을 보면서, -> [기능 이름] -> 기능들의 모음인 class가 무엇일지 생각해본다.
//        - [ ] 1부터 9까지 서로 다른 임의의 수 3개 생성한다. - createRandomNumbers()
//        - [ ] 컴퓨터의 수(3자리)와 플레이어의 수(3자리)를 비교할 수 있다. - compare()
    //        - [ ] 몇개의 숫자가 같은지 알 수 있다. - correctCount()
    //        - [ ] (추가) 특정 자리에  특정 숫자가 있는지 알 수 있다. (-> 이걸 알아야 아래 3개를 알 수 있음.) - hasPlace() 위치하냐
    //            - [ ] 같은 수가 다른 자리에 있으면 볼이다. - 이것들은 기능이 아닌가보다.
    //            - [ ] 같은 수가 같은 자리에 있으면 스트라이크이다. -
    //            - [ ] 같은 수가 전혀 없으면 낫싱이다.

        //4.기능들 이름이 정해지면, 각 기능들이 -> 어느 모음집 class에서 모을지 생각한다.
        // createRandomNumbers() -> (생성하는 것이므로 누가? 제네레이터) NumberGenerator#createRandomNumbers()
        // compare()-> (의인화해서 compare()하는 사람은 누구? 심판) Referee#compare()
            // correctCount() -> ( 몇개 숫자 같은지 아는 사람? 심판이 비교하는 과정에서 [판단]하는 것 중1 )
            // -> Judgement#correctCount()
            // hasPlace() -> 똑같은 들여쓰기, 심판이 비교하는 과정에서, [판단]하는 것 중2
            // -> Judgement#hasPlace()
        // -> readme도 다시 수정함.




    }
}
